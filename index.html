<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>入力テスト用ページ</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans JP', 'Yu Gothic UI', Meiryo, sans-serif; }
    .wrapper { display: flex; flex-direction: column; height: 100%; width: 100%; }
    .textarea-wrap { flex: 1 1 auto; padding: 12px; box-sizing: border-box; }
    textarea { width: 100%; height: 100%; box-sizing: border-box; resize: none; font-size: 18px; line-height: 1.6; padding: 12px; }
    .footer { flex: 0 0 auto; padding: 12px; border-top: 1px solid #ddd; position: sticky; bottom: 0; background: #fff; }
    button { width: 100%; padding: 14px 18px; font-size: 16px; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; background: #f6f6f6; }
    .hint { font-size: 12px; color: #666; margin-top: 8px; }
    .toast { position: fixed; right: 12px; bottom: 12px; background: #333; color: #fff; padding: 10px 12px; border-radius: 8px; opacity: 0.95; display: none; }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="textarea-wrap">
      <textarea id="editor" placeholder="ここにテキストを入れてください。"></textarea>
    </div>
    <div class="footer">
      <button id="copyBtn" type="button">クリップボードへコピー</button>
      <label style="display:flex;align-items:center;gap:8px;margin-top:8px;">
        <input id="autoCopy" type="checkbox" />
        自動コピー（変更を検知したらクリップボードへ転送）
      </label>
      <div id="autoStatus" class="hint" aria-live="polite"></div>
      <div class="hint">
        ※ HTTPS 環境（GitHub Pages 等）または localhost であれば、クリック操作でクリップボードへコピーできます。<br />
        ※ コピー後はネイティブアプリ側で <kbd>Ctrl</kbd>+<kbd>V</kbd> 等でペーストしてください。
      </div>
    </div>
  </div>
  <div id="toast" class="toast" role="status" aria-live="polite">コピーしました</div>
  <script>
    const ta = document.getElementById('editor');
    const copyBtn = document.getElementById('copyBtn');
    const toast = document.getElementById('toast');

    function showToast(msg) {
      toast.textContent = msg;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, 1500);
    }

    // ---- クリップボード共通関数（重複抑止付き） ----
    const LAST_KEY = 'lastCopiedFromThisSite';
    let lastCopied = localStorage.getItem(LAST_KEY) ?? '';

    async function readClipboardTop() {
      try {
        if (navigator.clipboard && window.isSecureContext && navigator.clipboard.readText) {
          return await navigator.clipboard.readText();
        }
      } catch (e) {}
      return null; // 読めない場合
    }

    async function writeClipboard(text) {
      // Modern API
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      // Fallback for non-secure contexts
      try {
        const selStart = ta.selectionStart, selEnd = ta.selectionEnd;
        const prev = ta.value;
        ta.select();
        const ok = document.execCommand('copy');
        ta.value = prev;
        ta.selectionStart = selStart;
        ta.selectionEnd = selEnd;
        ta.focus();
        return ok;
      } catch (e) {
        return false;
      }
    }

    /**
     * クリップボード履歴の重複増殖を抑止するコピー。
     * - 直前に本サイトがコピーした内容と同一 && クリップボードの先頭も同一ならスキップ（履歴を増やさない）
     * - それ以外は通常コピーして lastCopied を更新
     */
    async function copyWithDedupe(text) {
      const cur = text;
      // クリップボードの先頭を読める場合は確認
      const top = await readClipboardTop(); // null の場合は不明
      const duplicate = (cur === lastCopied) && (top === null || top === lastCopied || top === cur);
      if (duplicate) {
        // 同一内容での連打はスキップ（履歴を増やさない）
        return { ok: true, skipped: true };
      }
      const ok = await writeClipboard(cur);
      if (ok) {
        lastCopied = cur;
        try { localStorage.setItem(LAST_KEY, lastCopied); } catch {}
      }
      return { ok, skipped: false };
    }

    // 既存のボタンクリックに重複抑止版を適用
    copyBtn.addEventListener('click', async () => {
      const text = ta.value;
      try {
        const res = await copyWithDedupe(text);
        if (res.ok) {
          showToast(res.skipped ? '重複なのでコピーをスキップしました' : 'コピーしました');
        } else {
          alert('クリップボードへのコピーに失敗しました。HTTPS(またはlocalhost)での実行をご確認ください。');
        }
      } catch (err) {
        alert('クリップボードへのコピーでエラーが発生しました:\n' + err);
      }
    });

    window.addEventListener('DOMContentLoaded', () => { ta.focus(); });

    // === 自動コピー機能 ===
    const autoCopy = document.getElementById('autoCopy');
    const autoStatus = document.getElementById('autoStatus');
    const POLL_MS = 300;
    const MIN_INTERVAL_MS = 500;
    const SKIP_WHITESPACE_ONLY = true;

    let lastText = '';
    let lastCopiedAt = 0;
    let autoTimer = null;

    function hasMeaningfulChange(a, b) {
      if (a === b) return false;
      if (!SKIP_WHITESPACE_ONLY) return true;
      return a.replace(/\s+/g,'') !== b.replace(/\s+/g,'');
    }

    function setAutoStatus(msg) {
      autoStatus.textContent = msg;
    }

    async function pollAndCopy() {
      const now = Date.now();
      const cur = ta.value;
      if (hasMeaningfulChange(cur, lastText) && (now - lastCopiedAt) > MIN_INTERVAL_MS) {
        if (cur.length === 0) {
          lastText = cur;
          return;
        }
        const res = await copyWithDedupe(cur);
        if (res.ok) {
          if (!res.skipped) lastCopiedAt = now;
          lastText = cur;
          setAutoStatus(res.skipped ? '自動コピー：重複のためスキップ' : `自動コピー済み（${new Date().toLocaleTimeString()}）`);
        } else {
          setAutoStatus('クリップボードへの自動コピーに失敗しました。HTTPS または localhost で実行されているかをご確認ください。');
        }
      }
    }

    async function startAutoCopy() {
      lastText = ta.value;
      try {
        if (navigator.permissions && navigator.permissions.query) {
          await navigator.permissions.query({ name: "clipboard-write" });
        }
      } catch {}
      if (!autoTimer) {
        autoTimer = setInterval(pollAndCopy, POLL_MS);
        setAutoStatus('自動コピー：稼働中');
      }
    }

    function stopAutoCopy() {
      if (autoTimer) {
        clearInterval(autoTimer);
        autoTimer = null;
      }
      setAutoStatus('自動コピー：停止中');
    }

    autoCopy.addEventListener('change', (e) => {
      if (e.target.checked) {
        startAutoCopy();
      } else {
        stopAutoCopy();
      }
    });

    ta.addEventListener('input', () => {
      // pollAndCopy(); // 入力直後に即時コピーしたい場合に有効化
    });

    stopAutoCopy();
  </script>
</body>
</html>
